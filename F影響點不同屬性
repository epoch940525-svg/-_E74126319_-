from compas.datastructures import Mesh
from compas.geometry import Point
from compas_viewer import Viewer

import math
import copy


# PARAMETERS
OUTER_SIZE = 10.0
INNER_SIZE = 4.0
NX = 70
NY = 70

HOUSE_SIZE = 1.0
HOUSE_Z0 = 0.0

# ring thickness = house height / 5
RING_THICKNESS = HOUSE_SIZE / 5.0


# TWO SOURCES ONLY
# 主人= 凹（press）
# 外人 = 凸（push）
SOURCES = [
    {
        "name": "owner",
        "pos": (-2.5, 3.0, 0.0),
        "type": "press",   # 凹
        "radius": 3.2,
        "amp": 1.2,
    },
    {
        "name": "visitor",
        "pos": (4.5, 0.0, 0.0),
        "type": "push",    # 凸
        "radius": 2.5,
        "amp": 1.0,
    },
]

noise_level = 1.0
max_raise = 1.0


# GEOMETRY

def make_square_ring_mesh(outer, inner, nx, ny):
    ox = outer * 0.5
    oy = outer * 0.5
    hx = inner * 0.5
    hy = inner * 0.5

    vertices = []
    for j in range(ny + 1):
        y = -oy + (2 * oy) * (j / ny)
        for i in range(nx + 1):
            x = -ox + (2 * ox) * (i / nx)
            vertices.append([x, y, 0.0])

    faces = []
    for j in range(ny):
        for i in range(nx):
            a = i + j * (nx + 1)
            faces.append([a, a + 1, a + nx + 2, a + nx + 1])

    kept_faces = []
    for f in faces:
        cx = sum(vertices[k][0] for k in f) / 4
        cy = sum(vertices[k][1] for k in f) / 4
        if not (abs(cx) < hx and abs(cy) < hy):
            kept_faces.append(f)

    used = sorted({v for f in kept_faces for v in f})
    remap = {v: i for i, v in enumerate(used)}

    new_vertices = [vertices[v] for v in used]
    new_faces = [[remap[v] for v in f] for f in kept_faces]

    return Mesh.from_vertices_and_faces(new_vertices, new_faces)


def make_box_mesh(size, z0):
    s = size * 0.5
    z1 = z0 + size
    vertices = [
        [-s, -s, z0], [ s, -s, z0], [ s,  s, z0], [-s,  s, z0],
        [-s, -s, z1], [ s, -s, z1], [ s,  s, z1], [-s,  s, z1],
    ]
    faces = [
        [0,1,2,3],[4,5,6,7],
        [0,1,5,4],[1,2,6,5],
        [2,3,7,6],[3,0,4,7]
    ]
    return Mesh.from_vertices_and_faces(vertices, faces)


# DEFORMATION: OWNER (凹) / VISITOR (凸)

def deform_ring_identity(ring, sources):
    for v in ring.vertices():
        x, y, z0 = ring.vertex_coordinates(v)
        dz = 0.0

        for src in sources:
            px, py, _ = src["pos"]
            r = src["radius"]
            amp = src["amp"] * noise_level
            dx = x - px
            dy = y - py
            d = math.sqrt(dx*dx + dy*dy)

            if d >= r:
                continue

            t = 1.0 - d / r

            if src["type"] == "push":      # 外人
                dz += t * amp * max_raise

            elif src["type"] == "press":   # 主人
                dz -= t * amp * max_raise

        ring.vertex_attribute(v, "z", z0 + dz)

    return ring

# THICKENING (flat bottom, stretched sides)

def thicken_flat(ring_top, ring_base, thickness):
    solid = Mesh()

    top_map = {}
    for v in ring_top.vertices():
        x,y,z = ring_top.vertex_coordinates(v)
        top_map[v] = solid.add_vertex(x=x, y=y, z=z)

    bot_map = {}
    for v in ring_base.vertices():
        x,y,z = ring_base.vertex_coordinates(v)
        bot_map[v] = solid.add_vertex(x=x, y=y, z=z - thickness)

    for f in ring_top.faces():
        solid.add_face([top_map[v] for v in ring_top.face_vertices(f)])

    for f in ring_base.faces():
        solid.add_face([bot_map[v] for v in reversed(ring_base.face_vertices(f))])

    for u,v in ring_base.edges():
        if ring_base.halfedge[u][v] is None or ring_base.halfedge[v][u] is None:
            solid.add_face([top_map[u], top_map[v], bot_map[v], bot_map[u]])

    return solid

# BUILD

ring_base = make_square_ring_mesh(OUTER_SIZE, INNER_SIZE, NX, NY)
ring_top  = deform_ring_identity(copy.deepcopy(ring_base), SOURCES)
ring_solid = thicken_flat(ring_top, ring_base, RING_THICKNESS)

house = make_box_mesh(HOUSE_SIZE, HOUSE_Z0)

# VIEW

viewer = Viewer()
viewer.scene.add(ring_solid, name="ground", show_faces=True, show_edges=True)
viewer.scene.add(house, name="house", show_faces=True, show_edges=True)

for src in SOURCES:
    viewer.scene.add(Point(*src["pos"]), name=src["name"])

viewer.show()
